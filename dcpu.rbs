HW_KEYBOARD = 1
HW_SCREEN = 2
KBD_BS = 0x10

set pc, :_start
# z in the forth next instruction pointer
# i is the next forth instruction pointer
# j is the forth return stack pointer

label :DOCOL
begin
  sub j, 1
  set [j], i
  add z, 1
  set i, z
end

label :next
begin
  set z, [i]
  add i, 1
  set pc, [z]
end


defcode 'd' do
  set a, a
end

defcode 'INTERPRET' do
  set y, :interpret_word_buffer
  jsr :_word
  set [interpret_vars + 0], 0
  set [interpret_vars + 1], a   # length
  set [interpret_vars + 2], b   # pointer
  jsr :_find                    # find the dictionary entry
  ife a, 0 do                   # if we cant find it
    set pc, :interpret_lit      # check to see if it is a literal
  end
  # otherwise get the codeword
  set [interpret_vars + 3], a       # save the dictionary entry
  set [interpret_vars + 4], [a + 1] # save the lenght/mask word
  jsr :_tcfa                        # get the codeword
  set [interpret_vars + 3], a       # and save it
  set b, [interpret_vars + 4]       # get the length/mask word

  and_ b, IMMEDIATE_MASK
  ifn b, 0 do                   # if this is immediate
    set pc, :interpret_exec     # go straight to execute
  end

  set pc, :interpret_exec_or_compile # otherwise check to see if we are compiling or executing

  label :interpret_vars
  dat 0                         # is_literal (0)
  dat 0                         # word length (1)
  dat 0                         # word buffer (2)
  dat 0                         # dictionary_entry/codeword (3)
  dat 0                         # word length/mask (4)
  dat 0                         # literal (5)
  dat 0                         #

  # check to see if this is a literal
  label :interpret_lit
  set a, [interpret_vars + 1]   # get the length
  set x, [interpret_vars + 2]   # get the buffer
  jsr :_number                  # check to see if it is a number (returned in b)
  ifn a, 0 do                   # if not (a == number of charaters *not* converted)
    set pc, :interpret_error    # then we don't know what this is
  end
  set [interpret_vars + 3], :LIT # if it is a number then set the codeword to LIT
  set [interpret_vars + 0], 1   # and mark this as a literal
  set [interpret_vars + 5], b   # and save the number

  label :interpret_exec_or_compile
  set a, [var_STATE]            # check compiling or executing
  ife a, 0 do                   # if executing
    set pc, :interpret_exec
  end

  # compiling
  set a, [interpret_vars + 3]   # compiling
  jsr :_comma                   # store the codeword
  ife [interpret_vars + 0], 0 do # not literal
    set pc, :next                # we are finished
  end

  set a, [interpret_vars + 5]   # if it is literal then get the literal
  jsr :_comma                   # and compile it
  set pc, :next

  label :interpret_exec
  ifn [interpret_vars + 0], 0 do # if literal
    set pc, :interpret_push_lit
  end

  set z, [interpret_vars + 3]   # otherwise execute the codeword (just like next)
  set pc, [z]

  label :interpret_push_lit     # if it's a literal just push it and go to next
  set push, b
  set pc, :next

  label :interpret_error
end

label :interpret_word_buffer
space(32)

defcode 'NUMBER' do
  set a, pop                    # length
  set x, pop                    # pointer
  jsr :_number
  set push, b
  set push, a
end

# x points to buffer
# a length
# result in b
# a will be the number of unconverted chars

defsubr '_number' do
  set b, 0
  set push, 1
  ifn [x], -'-'
  set pc, :_number_loop
  set peek, -1 & 0xffff
  sub a, 1
  add x, 1
  label :_number_loop
  ife a, 0
  set pc, :_number_finish

  set c, [x]
  add x, 1

  sub c, '0'.ord
  ifg 0, c                      # c < 0 error
  set pc, :_number_finish
  ifg c, 10
  sub c, 'A'.ord - '0'.ord - 10
  ifg c, 35
  sub c, 'a'.ord - 'A'.ord
  ifg c, 35
  set pc, :_number_finish
  ifg [var_BASE], c
  set pc, :_number_calc
  set pc, :_number_finish

  label :_number_calc
  sub a, 1
  mul b, [var_BASE]
  add b, c
  set pc, :_number_loop

  label :_number_finish
  mul b, pop
end

defcode 'WORD' do
  set y, wordbuf
  jsr :_word
  set push, b
  set push, a
end


# input
#  y pointer to buffer to fill w/ word
# output
#  a length
#  b buffer
defsubr '_word' do
  set push, y                   # save the buffer pointer
  set [:_word_count], 0

  label :word_skip
  jsr :_getc
  jsr :_upcase
  ife a, -' '
  set pc, :word_skip
  ife a, KBD_CR
  set pc, :word_skip
  ife a, -'\\'
  set pc, :word_eol

  label :word_loop
  set [y], a
  add y, 1
  add [:_word_count], 1
  jsr :_getc
  jsr :_upcase
  ife a, -' '
  set pc, :word_exit
  ife a, KBD_CR
  set pc, :word_exit
  set pc, :word_loop

  label :word_eol
  jsr :_getc
  jsr :_upcase
  ifn a, KBD_CR
  set pc, :word_eol
  set pc, :word_skip

  label :word_exit
  set a, [:_word_count]
  set b, pop                    # return the original pointer
end

label :_word_count
dat 0

space(32, wordbuf)

defcode 'KEY' do
  jsr :_getc
  set push, a
end

defcode 'LITSTRING' do
  set a, [i]
  add i, 1
  set push, i
  add i, a
  set push, a
end

defcode 'BREAK' do
  set a, peek
end

defcode 'FIND' do
  set a, pop                    # length
  set b, pop                    # string
  jsr :_find
  set push, a
end

# input
#  a length
#  b ptr to string
# output
#  a dictionary entry
defsubr :_find do
  set y, b
  set x, var_LATEST
  set push, x

  label :find_next
  set x, peek
  set x, [x]
  set peek, x

  ife x, 0
  set pc, :find_exit
  add x, 1
  set c, [x]
  and_ c, LENGTH_MASK | HIDDEN_MASK
  ifn c, a
  set pc, :find_next
  add x, 1
  set b, y

  label :find_cloop
  ife c, 0
  set pc, :find_exit
  ifn [b], [x]
  set pc, :find_next
  sub c, 1
  add x, 1
  add b, 1
  set pc, :find_cloop

  label :find_exit
  set a, pop
end

defcode 'EXIT' do
  set i, [j]
  add j, 1
end

defcode 'DUP' do
  set a, peek
  set push, a
end

defcode 'SWAP' do
  set a, pop
  set b, pop
  set push, a
  set push, b
end

defcode 'DROP' do
  set a, pop
end

defcode 'OVER' do
  set x, sp
  set a, [x + 1]
  set push, a
end

defcode 'ROT' do
  set a, pop
  set b, pop
  set c, pop
  set push, b
  set push, a
  set push, c
end

defcode '-ROT', 'NROT' do
  set a, pop
  set b, pop
  set c, pop
  set push, a
  set push, c
  set push, b
end

defcode '2DROP', 'TWODROP' do
  set a, pop
  set a, pop
end

defcode '2DUP', 'TWODUP' do
  set a, pop
  set b, peek
  set push, a
  set push, b
  set push, a
end

defcode '2SWAP', 'TWOSWAP' do
  set a, pop
  set b, pop
  set c, pop
  set x, pop
  set push, b
  set push, a
  set push, x
  set push, c
end

defcode '?DUP', 'QDUP' do
  set a, peek
  ifn a, 0
  set push, a
end

defcode '1+', 'INCR' do
  add peek, 1
end

defcode '1-', 'DECR' do
  sub peek, 1
end

defcode '+', 'FADD' do
  set a, pop
  add peek, a
end

defcode '-', 'FSUB' do
  set a, pop
  sub peek, a
end

defcode '*', 'FMUL' do
  set a, pop
  mul peek, a
end

defcode '/MOD', 'DIVMOD' do
  set b, pop
  set a, peek
  mod peek, b
  set push, a
  div peek, b
end

defcode '=', 'EQ' do
  set a, pop
  set b, pop
  set push, 0
  ife a, b
  set peek, 1
end

defcode '<>', 'NEQ' do
  set a, pop
  set b, pop
  set push, 0
  ifn a, b
  set peek, 1
end


# true if a < b
defcode '<', 'LT' do
  set b, pop
  set a, pop
  set push, 0
  ifg b, a
  set peek, 1
end

# true if a > b
defcode '>', 'GT' do
  set b, pop
  set a, pop
  set push, 0
  ifg a, b
  set peek, 1
end

# true if a <= b
defcode '<=', 'LE' do
  set b, pop
  set a, pop
  set push, 1
  ifg a, b
  set peek, 0
end

# true if a >= b
defcode '>=', 'GE' do
  set b, pop
  set a, pop
  set push, 1
  ifg b, a
  set peek, 0
end

defcode '0=', 'ZEQ' do
  set a, pop
  set push, 0
  ife a, 0
  set peek, 1
end

defcode '0<>', 'ZNEQ' do
  set a, pop
  set push, 0
  ifn a, 0
  set peek, 1
end

# true if a < 0
defcode '0<', 'ZLT' do
  set a, pop
  set push, 0
  ifg 0, a
  set peek, 1
end

defcode '0>', 'ZGT' do
  set a, pop
  set push, 0
  ifg a, 0
  set peek, 1
end

defcode '0<=', 'ZLE' do
  set a, pop
  set push, 1
  ifg a, 0
  set peek, 0
end

defcode '0>=', 'ZGE' do
  set a, pop
  set push, 1
  ifg 0, a
  set peek, 0
end

defcode 'AND', 'FAND' do
  set a, pop
  and_ peek, a
end

defcode 'OR' do
  set a, pop
  bor peek, a
end

defcode 'XOR', 'FXOR' do
  set a, pop
  xor peek, a
end

defcode 'INVERT' do
  xor peek, 0xffff
end

defcode 'LIT' do
  set a, [i]
  add i, 1
  set push, a
end

defcode '!', 'STORE' do
  set x, pop
  set a, pop
  set [x], a
end

defcode '@', 'FETCH' do
  set x, pop
  set push, [x]
end

defcode '+!', 'ADDSTORE' do
  set x, pop
  set a, pop
  add [x], a
end

defcode '-!', 'SUBSTORE' do
  set x, pop
  set a, pop
  sub [x], a
end

defvar "base", 10
defvar 'state', 0
defvar "s0"
defvar "here", :text_end


defcode "DSP@", 'DSPFETCH' do
  set a, sp
  set push, a
end

defcode "DSP!", 'DSPSTORE' do
  set a, pop
  set sp, a
end

defcode '>R', 'TOR' do
  set a, pop
  sub j, 1
  set j, a
end

defcode 'R>', 'FROMR' do
  set a, j
  add j, 1
  set push, a
end

defcode 'RDROP' do
  add j, 1
end

defcode 'RSP@', 'RSPFETCH' do
  set push, j
end

defcode 'RSP!', 'RSPSTORE' do
  set j, pop
end

defcode '>CFA', 'TCFA' do
  set a, pop
  jsr :_tcfa
  set push, a
end

# i/o a
defsubr :_tcfa do
  add a, 1
  set b, [a]
  add a, 1
  and_ b, LENGTH_MASK
  add a, b
end

defword '>dfa', :lab => 'tdfa' do
  w tcfa
  w incr
end

defcode 'CREATE' do
  set a, pop
  set b, pop
  set x, [var_HERE]
  set [x], [var_LATEST]
  set [var_LATEST], x # update latest
  add x, 1
  set [x], a
  add x, 1

  label :create_cloop
  ife a, 0
  set pc, :create_cloop_end
  set [x], [b]
  sub a, 1
  add x, 1
  add b, 1
  set pc, :create_cloop
  label :create_cloop_end

  set [var_HERE], x
end


defcode ',', 'COMMA' do
  set a, pop
  jsr :_comma
end

defsubr :_comma do
  set b, [var_HERE]
  set [b], a
  add [var_HERE], 1
end

defcode '[', :lab => 'LBRAC', :flags => IMMEDIATE_MASK do
  set [var_STATE], 0
end

defcode ']', 'RBRAC' do
  set [var_STATE], 1
end

defword ':', :lab => 'COLON' do
  w word
  w create
  w lit, docol, comma
  w latest, fetch, hidden
  w rbrac
end

defcode 'emit' do
  set a, pop
  jsr :_echo
end

defword ';', :lab => 'SEMICOLON', :flags => IMMEDIATE_MASK do
  w lit, exit_, comma
  w latest, fetch, hidden
  w lbrac
end

defcode 'IMMEDIATE', :flags => IMMEDIATE_MASK do
  set x, [var_LATEST]
  add x, 1
  set a, [x]
  bor a, IMMEDIATE_MASK
  set [x], a
end

defcode 'HIDDEN' do
  set x, pop
  add x, 1
  set a, [x]
  xor a, HIDDEN_MASK
  set [x], a
end

defword 'hide' do
  w word
  w find
  w hidden
end

defcode 'char' do
  jsr :_word
  # a = length, b = buffer
  set push, [b]
end


defcode "'", 'TICK' do
  set push, [i]
  add i, 1
end

defcode 'BRANCH' do
  set a, [i]
  add i, a
end

defcode '0BRANCH', 'ZBRANCH' do
  set a, pop
  set b, [i]
  sub b, 1
  add i, 1
  ife a, 0
  add i, b
end

defconst "R0", 0x7000, :lab => 'rz'

defword 'quit' do
  w rz, rspstore
  w interpret
  w branch, -2 & 0xffff
end

defsubr :_ram_test do
  jsr :_getc
  set pc, :_ram_test
end

defsubr :_getc, :saves => [y] do
  ifg [:var_GETC_BUFFER_LIMIT], [:var_GETC_BUFFER_NEXTCHAR]
  set pc, :_getc_skip_read

  set y, :_getc_buffer
  jsr :_read_line
  set [:var_GETC_BUFFER_LIMIT], y
  set [:var_GETC_BUFFER_NEXTCHAR], :_getc_buffer

  label :_getc_skip_read
  set y, [:var_GETC_BUFFER_NEXTCHAR]
  set a, [y]
  add [:var_GETC_BUFFER_NEXTCHAR], 1
end

# buffer_end => y
# b => line_length
# munges a, b, c, x, y
defsubr :_read_line do
  set b, 0                      # set the number of characters read into buffer
  label :_read_line_next
  jsr :_key                     # get (non-blocking) character
  ife a, 0
  set pc, :_read_line_next      # if none loop
  jsr :_echo                    # echo it to the screen
  ifn a, KBD_BS                 # if it is a backspace
  set pc, :_read_line_skip_bs
  ife b, 0                      # and we have some characters in the buffer
  set pc, :_read_line_next
  sub b, 1                      # backup the buffer
  sub y, 1
  set pc, :_read_line_next

  label :_read_line_skip_bs
  set [y], a                    # add this character to the buffer
  add b, 1
  add y, 1
  ifn a, KBD_CR                 # quit when we get a CR
  set pc, :_read_line_next
end

# 0 or <next-char>  => a
# munges c, x
defsubr :_key do
  set a, 1
  hwi HW_KEYBOARD
  set a, c
end

defsubr _upcase do
  ifg 0x61, a
  set pc, pop
  ifg a, 0x7a
  set pc, pop
  sub a, 0x20
end

# a => character to echo on screen
# b => line-length
# munges: x
defsubr '_echo' do
  set x, [var_NEXTOUT]

  ifn a, KBD_CR
  set pc, :echo_skip_nl
  set [x], 0
  add x, 32
  and_ x, 0xffe0
  set pc, :_echo_finish

  label :echo_skip_nl
  ifn a, KBD_BS
  set pc, :echo_skip_bs
  ife b, 0
  set pc, pop
  set [x], 0
  sub x, 1
  set pc, :_echo_finish

  label :echo_skip_bs
  bor a, 0xf000
  set [x], a
  add x, 1
  label :_echo_finish
  ifg x, 0x817f
  jsr :_scroll
  and_ a, 0x7f
  set [var_NEXTOUT], x
  set [x], 0x809c
end

defsubr '_scroll' do
  set x, 0x8000
  label :_scroll_loop1
  set [x], [x + 32]
  add x, 1
  ifg 0x8160, x
  set pc, :_scroll_loop1

  label :_scroll_loop2
  set [x], 0
  add x, 1
  ifg 0x8180, x
  set pc, :_scroll_loop2
  set x, 0x8160
end

defvar 'nextchar', 0x9000
defvar 'nextout', 0x8000

defvar 'getc_buffer_limit', :text_end
defvar 'getc_buffer_nextchar', :text_start

# this has to be last
defvar "latest", name_LATEST

label :_getc_buffer
space(256)

label :_start
begin
  jsr :_setup_screen
  jsr :_setup_kbd

  set push, 0
  set [var_S0], sp
  set j, 0x7000
  set i, :_cold_start
  set pc, :next
end

defsubr :_setup_kbd do
  set a, 0
  hwi HW_KEYBOARD
end

defsubr :_setup_screen do
  set a, 0
  set b, [var_NEXTOUT]
  hwi HW_SCREEN
end


label :_cold_start
w :quit

label :text_start

forth %(
: '\\n' #{KBD_CR} ;
: BL #{' '.ord} ;
: CR '\\n' EMIT ;
: SPACE BL EMIT ;
: NEGATE 0 SWAP - ;
: TRUE  1 ;
: FALSE 0 ;
: NOT   0= ;

: LITERAL IMMEDIATE
        \' LIT ,        \\ compile LIT
        ,               \\ compile the literal itself from the stack
        ;

: ':'
        [               \\ go into immediate mode (temporarily)
        CHAR :          \\ push the number 58 (ASCII code of colon) on the parameter stack
        ]               \\ go back to compile mode
        LITERAL         \\ compile LIT 58 as the definition of ':' word
;

: ';' [ CHAR ; ] LITERAL ;
: '(' [ CHAR ( ] LITERAL ;
: ')' [ CHAR ) ] LITERAL ;
: '\"' [ CHAR \" ] LITERAL ;
: 'A' [ CHAR A ] LITERAL ;
: '0' [ CHAR 0 ] LITERAL ;
: '-' [ CHAR - ] LITERAL ;
: '.' [ CHAR . ] LITERAL ;

: [COMPILE] IMMEDIATE
        WORD            \\ get the next word
        FIND            \\ find it in the dictionary
        >CFA            \\ get its codeword
        ,               \\ and compile that
;

: RECURSE IMMEDIATE
        LATEST @        \\ LATEST points to the word being compiled at the moment
        >CFA            \\ get the codeword
        ,               \\ compile it
;

: IF IMMEDIATE
        \' 0BRANCH ,    \\ compile 0BRANCH
        HERE @          \\ save location of the offset on the stack
        0 ,             \\ compile a dummy offset
;

: THEN IMMEDIATE
        DUP
        HERE @ SWAP -   \\ calculate the offset from the address saved on the stack
        SWAP !          \\ store the offset in the back-filled location
;

: ELSE IMMEDIATE
        \' BRANCH ,     \\ definite branch to just over the false-part
        HERE @          \\ save location of the offset on the stack
        0 ,             \\ compile a dummy offset
        SWAP            \\ now back-fill the original (IF) offset
        DUP             \\ same as for THEN word above
        HERE @ SWAP -
        SWAP !
;

: BEGIN IMMEDIATE
        HERE @          \\ save location on the stack
;

: UNTIL IMMEDIATE
        \' 0BRANCH ,    \\ compile 0BRANCH
        HERE @ -        \\ calculate the offset from the address saved on the stack
        ,               \\ compile the offset here
;

: AGAIN IMMEDIATE
        \' BRANCH ,     \\ compile BRANCH
        HERE @ -        \\ calculate the offset back
        ,               \\ compile the offset here
;

: WHILE IMMEDIATE
        \' 0BRANCH ,    \\ compile 0BRANCH
        HERE @          \\ save location of the offset2 on the stack
        0 ,             \\ compile a dummy offset2
;

: REPEAT IMMEDIATE
        \' BRANCH ,     \\ compile BRANCH
        SWAP            \\ get the original offset (from BEGIN)
        HERE @ - ,      \\ and compile it after BRANCH
        DUP
        HERE @ SWAP -   \\ calculate the offset2
        SWAP !          \\ and back-fill it in the original location
;

: UNLESS IMMEDIATE
        \' NOT ,        \\ compile NOT (to reverse the test)
        [COMPILE] IF    \\ continue by calling the normal IF
;

: \( IMMEDIATE
        1               \\ allowed nested parens by keeping track of depth
        BEGIN
                KEY             \\ read next character
                DUP '\(' = IF    \\ open paren?
                        DROP            \\ drop the open paren
                        1+              \\ depth increases
                ELSE
                        '\)' = IF        \\ close paren?
                                1-              \\ depth decreases
                        THEN
                THEN
        DUP 0= UNTIL            \\ continue until we reach matching close paren, depth 0
        DROP            \\ drop the depth counter
;

: NIP ( x y -- y ) SWAP DROP ;
: TUCK ( x y -- y x y ) SWAP OVER ;
: PICK ( x_u ... x_1 x_0 u -- x_u ... x_1 x_0 x_u )
        1+              ( add one because of 'u' on the stack )
        DSP@ +          ( add to the stack pointer )
        @               ( and fetch )
;

: SPACES        ( n -- )
        BEGIN
                DUP 0>          ( while n > 0 )
        WHILE
                SPACE           ( print a space )
                1-              ( until we count down to 0 )
        REPEAT
        DROP
;

: DECIMAL ( -- ) 10 BASE ! ;
: HEX ( -- ) 16 BASE ! ;

: U.            ( u -- )
        BASE @ /MOD     ( width rem quot )
        ?DUP IF                 ( if quotient <> 0 then )
                RECURSE         ( print the quotient )
        THEN

        ( print the remainder )
        DUP 10 < IF
                '0'             ( decimal digits 0..9 )
        ELSE
                10 -            ( hex and beyond digits A..Z )
                'A'
        THEN
        +
        EMIT
;

: .S            ( -- )
        DSP@            ( get current stack pointer )
        BEGIN
                DUP S0 @ <
        WHILE
                DUP @ U.        ( print the stack element )
                SPACE
                1+              ( move up )
        REPEAT
        DROP
;

: UWIDTH	( u -- width )
	BASE @ /	( rem quot )
	?DUP IF		( if quotient <> 0 then )
		RECURSE 1+	( return 1+recursive call )
	ELSE
		1		( return 1 )
	THEN
;

)

label :text_end
